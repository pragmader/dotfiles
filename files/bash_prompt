PROMPT_COMMAND="__prompt"

# colors
# regular
red="\[\033[0;31m\]"
green="\[\033[0;32m\]"

# bold
bold_red="\[\033[1;31m\]";
bold_green="\[\033[1;32m\]";
bold_yellow="\[\033[1;33m\]";
bold_white="\[\033[1;37m\]";

# high intensity
light_yellow="\[\033[0;93m\]";

# high intensity bold
bold_light_blue="\[\033[1;94m\]";
bold_light_purple="\[\033[1;95m\]"

bg_red="\[\033[41m\]"

reset="\[\033[0m\]"

# displays `ssh://` if it's a remote shell
__prompt_ssh() {
	if [[ "${SSH_TTY}" ]]; then
		printf "${yellow}ssh://${reset}"
	fi;
}

# displays the amount of jobs running in the shell if any
__prompt_jobs_count() {
  local stopped=$(jobs -sp | wc -l | sed -e 's/[[:space:]]//g') # on Mac there are extra spaces in the output
  local running=$(jobs -rp | wc -l | sed -e 's/[[:space:]]//g')
  ((running+stopped)) && printf "[${green}${running}${reset}/${red}${stopped}${reset}]"
}

# paints the following text red if the last status code was not zero, green otherwise
__prompt_last_exit_code_color() {
	local exit_color=$bold_green

	if [[ $1 -ne 0 ]]; then
		exit_color=$bold_red
	fi
	printf "${exit_color}"
}

# displays git information: branch name, status flags
__prompt_git_status() {
	if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" == 'true' ]; then
		# Get the short symbolic ref.
		# If HEAD isnâ€™t a symbolic ref, get the short SHA for the latest commit
		# Otherwise display `~error~`.
		local branch_name="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
										git rev-parse --short HEAD 2> /dev/null || \
										printf ${reset}${bg_red}${bold_white}error)";

		printf "${bold_light_blue}@${branch_name}${reset}"

		# check if the current directory is in .git before running git checks
		if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then
			# Ensure the index is up to date.
			git update-index --really-refresh -q &>/dev/null;

			printf "${bold_yellow}"

			# Check for uncommitted changes in the index.
			if ! $(git diff --quiet --ignore-submodules --cached); then
				printf '|c';
			fi;

			# Check for unstaged changes.
			if ! $(git diff-files --quiet --ignore-submodules --); then
				printf '|s';
			fi;

			# Check for untracked files.
			if [ -n "$(git ls-files --others --exclude-standard)" ]; then
			  printf '|t';
			fi;

			printf "${reset}"
		fi;
	else
		return;
	fi;
}

__prompt() {
	local exit_code=$?
	# because some programs don't respect UNIX conventions and don't print \n
	PS1="\n"
	# indicate SSH connection
	PS1+="$(__prompt_ssh)"
	# username and hostname
	PS1+="${bold_light_purple}\u${reset}${bold_light_blue}@\H${reset}"
	# working directory
	PS1+="${bold_white}\w${reset}"
	# amount of background jobs
	PS1+="$(__prompt_git_status)"
	# amount of background jobs
	PS1+="$(__prompt_jobs_count)"
	# red if the last exit code was non-zero
	PS1+=" $(__prompt_last_exit_code_color ${exit_code})\$${reset} "
	# so all new terminals are open in the same directory
	echo $PWD > ~/.last_dir
}
